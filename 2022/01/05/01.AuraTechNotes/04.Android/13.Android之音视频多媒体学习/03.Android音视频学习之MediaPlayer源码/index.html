<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android音视频学习之MediaPlayer源码 | 麦溪·在路上</title><meta name="author" content="Frewen.Wang"><meta name="copyright" content="Frewen.Wang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="页面描述"><link rel="shortcut icon" href="/img/frewen_tech.png"><link rel="canonical" href="http://www.frewen.wang/2022/01/05/01.AuraTechNotes/04.Android/13.Android%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0/03.Android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E4%B9%8BMediaPlayer%E6%BA%90%E7%A0%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android音视频学习之MediaPlayer源码',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-05 00:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/frewen_tech.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">858</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">146</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 文章标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章归类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/page_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="麦溪·在路上"><span class="site-name">麦溪·在路上</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 文章标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章归类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Android音视频学习之MediaPlayer源码</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-04T16:00:00.000Z" title="发表于 2022-01-05 00:00:00">2022-01-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-04T16:00:00.000Z" title="更新于 2022-01-05 00:00:00">2022-01-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android音视频学习之MediaPlayer源码"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/01/05/01.AuraTechNotes/04.Android/13.Android%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0/03.Android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E4%B9%8BMediaPlayer%E6%BA%90%E7%A0%81/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/01/05/01.AuraTechNotes/04.Android/13.Android%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0/03.Android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E4%B9%8BMediaPlayer%E6%BA%90%E7%A0%81/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MediaPlayer是Android中的一个多媒体播放类，我们能通过它控制音视频流或本地音视频资源的播放过程。</p>
<p>MediaPlayer类用于视频&#x2F;音频文件的播放控制。本节主要覆盖MediaPlayer如下知识点。</p>
<p>• MediaPlayer的状态图</p>
<p>•  Idle状态</p>
<p>• End状态</p>
<p>• Error状态</p>
<p>• Initialized状态</p>
<p>• Prepared状态</p>
<p>• Preparing状态</p>
<p>• Started状态</p>
<p>• Paused状态</p>
<p>• Stopped状态</p>
<p>• PlaybackCompleted状态</p>
<h2 id="MediaPlayer的状态图"><a href="#MediaPlayer的状态图" class="headerlink" title="MediaPlayer的状态图"></a>MediaPlayer的状态图</h2><p><img src="/images/epub_31186334_5.jpeg" alt="img"></p>
<h2 id="Idle状态及End状态"><a href="#Idle状态及End状态" class="headerlink" title="Idle状态及End状态"></a>Idle状态及End状态</h2><p>在MediaPlayer创建实例或者调用reset函数后，播放器就被创建了，这时处于Idle（就绪）状态，调用release函数后，就会变成End（结束）状态，在这两种状态之间的就是MediaPlayer的生命周期。</p>
<h2 id="Error状态"><a href="#Error状态" class="headerlink" title="Error状态"></a>Error状态</h2><p>在构造一个新MediaPlayer或者调用reset函数后，上层应用程序调用getCurrentPosition、getVideoHeight、getDuration、getVideoWidth、setAudioStreamType(int)、setLooping(boolean)、setVolume(float,float)、pause、start、stop、seekTo(int)、prepare、prepareAsync这些函数会出错。如果调用reset函数后再调用它们，用户提供的回调函数OnErrorListener.onError将触发MediaPlayer状态到Error（错误）状态，所以一旦不再使用MediaPlayer，就需要调用release函数，以便MediaPlayer资源得到合理释放。</p>
<p>当MediaPlayer处于End（结束）状态时，它将不能再被使用，这时不能再回到MediaPlayer的其他状态，因为本次生命周期已经终止。</p>
<p>由于支持的音视频格式分辨率过高，输入数据流超时，或者其他各种各样的原因将导致播放失败。在这种错误的条件下，如果用户事先通过setOnErrorListener注册过OnErrorListener，当player内部调用OnErrorListener.onError回调函数时，将会返回错误信息。一旦有错误，MediaPlayer会进入Error（错误）状态，为了重新使用MediaPlayer，调用reset函数，这时将重新恢复到Idle（就绪）状态，所以需要给MediaPlayer设置错误监听，出错后就可以从播放器内部返回的信息中找到错误原因。</p>
<h2 id="Initialized状态"><a href="#Initialized状态" class="headerlink" title="Initialized状态"></a>Initialized状态</h2><p>当调用setDataSource(FileDescriptor)、setDataSource(String)、setDataSource(Context, Uri)、setDataSource(FileDescriptor, long, long)其中一个函数时，将传递MediaPlayer的Idle状态变成Initialized（初始化）状态，如果setDataSource在非Idle状态时调用，会抛出IllegalStateException异常。当重载setDataSource时，需要抛出IllegalArgumentException和IOException这两个异常。</p>
<h2 id="Prepared状态"><a href="#Prepared状态" class="headerlink" title="Prepared状态"></a>Prepared状态</h2><h2 id="MediaPlayer创建"><a href="#MediaPlayer创建" class="headerlink" title="MediaPlayer创建"></a>MediaPlayer创建</h2><p>当外部调用MediaPlayer.create(this, ＂<a href="http://www.xxx.mp4＂)时，进入MediaPlayer的创建过程：">http://www.xxx.mp4＂)时，进入MediaPlayer的创建过程：</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MediaPlayer <span class="title function_">create</span><span class="params">(Context context, Uri uri, SurfaceHolder holder,</span></span><br><span class="line"><span class="params">                                     AudioAttributes audioAttributes, <span class="type">int</span> audioSessionId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// MediaPlayer的静态create方法</span></span><br><span class="line">            <span class="type">MediaPlayer</span> <span class="variable">mp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaPlayer</span>(audioSessionId);</span><br><span class="line">            <span class="comment">// 声音相关的处理，若为空，则创建</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AudioAttributes</span> <span class="variable">aa</span> <span class="operator">=</span> audioAttributes != <span class="literal">null</span> ? audioAttributes :</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">AudioAttributes</span>.Builder().build();</span><br><span class="line">            <span class="comment">// 设置音频属性</span></span><br><span class="line">            mp.setAudioAttributes(aa);</span><br><span class="line">            mp.native_setAudioSessionId(audioSessionId);</span><br><span class="line">            <span class="comment">// 设置声音的会话ID，音频和视频是分开渲染的</span></span><br><span class="line">            <span class="comment">// 设置dataSource uri即统一资源定位符</span></span><br><span class="line">            mp.setDataSource(context, uri);</span><br><span class="line">            <span class="comment">// 判断surfaceHolder是否为空，这是一个控制器</span></span><br><span class="line">            <span class="comment">// Surface的控制器，用来操纵Surface.处理它在Canvas上作画的效果和动画控制表面、大小、像素等</span></span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 给Surface设置一个suface的控制器</span></span><br><span class="line">                mp.setDisplay(holder);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开始准备</span></span><br><span class="line">            mp.prepare();</span><br><span class="line">            <span class="keyword">return</span> mp;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;create failed:&quot;</span>, ex);</span><br><span class="line">            <span class="comment">// fall through</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;create failed:&quot;</span>, ex);</span><br><span class="line">            <span class="comment">// fall through</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;create failed:&quot;</span>, ex);</span><br><span class="line">            <span class="comment">// fall through</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>以上代码可以总结为，当MediaPlayer通过create的方式创建播放器时，内部new出MediaPlayer对象，并setDataSource，做好prepare的动作。这时外部只需调用start函数，就能播放音视频资源了。</p>
<p>实例化MediaPlayer有如下两种方式。</p>
<p>（1）可以使用直接new的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MediaPlayer</span> <span class="variable">mp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaPlayer</span>();</span><br></pre></td></tr></table></figure>

<p>（2）也可以使用create的方式，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MediaPlayer</span> <span class="variable">mp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaPlayer</span>(<span class="built_in">this</span>,R.raw.test);</span><br></pre></td></tr></table></figure>

<p>上面两种实例化MediaPlayer的方式，都要经过new MediaPlayer，下面看看构造中做了什么操作。</p>
<p>播放页处理主页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">MediaPlayer</span><span class="params">(<span class="type">int</span> sessionId)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">AudioAttributes</span>.Builder().build(),</span><br><span class="line">            AudioPlaybackConfiguration.PLAYER_TYPE_JAM_MEDIAPLAYER);</span><br><span class="line">    <span class="comment">// 定义一个Looper</span></span><br><span class="line">    Looper looper;</span><br><span class="line">    <span class="comment">// 通过Looper.myLooper()获取当前的线程绑定的Looper。如果不为null,则赋值到looper，创建EventHandler</span></span><br><span class="line">    <span class="keyword">if</span> ((looper = Looper.myLooper()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        mEventHandler = <span class="keyword">new</span> <span class="title class_">EventHandler</span>(<span class="built_in">this</span>, looper);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((looper = Looper.getMainLooper()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果主线程不为null，也可以赋值到looper，创建EventHandler</span></span><br><span class="line">        mEventHandler = <span class="keyword">new</span> <span class="title class_">EventHandler</span>(<span class="built_in">this</span>, looper);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mEventHandler = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 时间数据容器，一般Provider都是和数据联系起来，如VideoProvider、ContentProvider</span></span><br><span class="line">    mTimeProvider = <span class="keyword">new</span> <span class="title class_">TimeProvider</span>(<span class="built_in">this</span>);</span><br><span class="line">    mOpenSubtitleSources = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;InputStream&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">AttributionSource</span> <span class="variable">attributionSource</span> <span class="operator">=</span> AttributionSource.myAttributionSource();</span><br><span class="line">    <span class="comment">// set the package name to empty if it was null</span></span><br><span class="line">    <span class="keyword">if</span> (attributionSource.getPackageName() == <span class="literal">null</span>) &#123;</span><br><span class="line">        attributionSource = attributionSource.withPackageName(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Native setup requires a weak reference to our object.</span></span><br><span class="line"><span class="comment">     * It&#x27;s easier to create it here than in C++.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 调用native层的setup</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ScopedParcelState</span> <span class="variable">attributionSourceState</span> <span class="operator">=</span> attributionSource.asScopedParcelState()) &#123;</span><br><span class="line">        native_setup(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;MediaPlayer&gt;(<span class="built_in">this</span>), attributionSourceState.getParcel());</span><br><span class="line">    &#125;</span><br><span class="line">    baseRegisterPlayer(sessionId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看Native层如何创建一个MediaPlayer。在介绍native_setup之前，请注意一般都是在静态代码块中加载.so文件的，在MediaPlayer中有一段静态代码块，用于加载和链接库文件media_jni.so，早于构造函数，在加载类时就执行。一般全局性的数据、变量都可以放在这里。下面是加载和链接media_jni.so文件的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       System.loadLibrary(<span class="string">&quot;media_jni&quot;</span>);</span><br><span class="line">       native_init();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">native_init</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>我们看看native_init的函数的具体实现：</p>
<p>下面开始进入android_media_MediaPlayer.cpp分析，第一个函数android_media_MediaPlayer_native_init就是从Java静态代码块调过来的native_init：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_media_MediaPlayer_native_init</span><span class="params">(JNIEnv *env)</span></span>&#123;</span><br><span class="line">    <span class="comment">// *env可以理解为万能指针表。通过操作符(-&gt;）访问JNI函数</span></span><br><span class="line">    <span class="comment">// frameworks/base/media/java/android/media/MediaPlayer.java</span></span><br><span class="line">    <span class="comment">// 定义jclass的对象，通过env-&gt;FindClass(全路径名)拿到class对象）</span></span><br><span class="line">    <span class="comment">// 通过Native层调用Java层获取MediaPlayer对象</span></span><br><span class="line">    jclass clazz;</span><br><span class="line">    clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;android/media/MediaPlayer&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取MediaPlayer中mNativeContext，它在MediaPlayer.java中是一个long型整数。实际对象的是一个内存地址</span></span><br><span class="line">    fields.context = env-&gt;<span class="built_in">GetFieldID</span>(clazz, <span class="string">&quot;mNativeContext&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fields.context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取MediaPlayer中postEventFromNative的静态方法，后面是方法的描述表</span></span><br><span class="line">    fields.post_event = env-&gt;<span class="built_in">GetStaticMethodID</span>(clazz, <span class="string">&quot;postEventFromNative&quot;</span>,</span><br><span class="line">                                               <span class="string">&quot;(Ljava/lang/Object;IIILjava/lang/Object;)V&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fields.post_event == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    gPlaybackParamsFields.<span class="built_in">init</span>(env);</span><br><span class="line">    gSyncParamsFields.<span class="built_in">init</span>(env);</span><br><span class="line">    gVolumeShaperFields.<span class="built_in">init</span>(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种方式是通过JNI调用Java层的MediaPlayer类，然后拿到mNativeContext的指针，接着调用了MediaPlayer.java中的静态方法postEventFromNative，把Native的事件回调到Java层，使用EventHandler post事件回到主线程中，用软引用指向原生的MediaPlayer，以保证Native代码是安全的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postEventFromNative</span><span class="params">(Object mediaplayer_ref,</span></span><br><span class="line"><span class="params">                                        <span class="type">int</span> what, <span class="type">int</span> arg1, <span class="type">int</span> arg2, Object obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到MediaPlayer的软引用对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MediaPlayer</span> <span class="variable">mp</span> <span class="operator">=</span> (MediaPlayer)((WeakReference)mediaplayer_ref).get();</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mp.mEventHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> mp.mEventHandler.obtainMessage(what, arg1, arg2, obj);</span><br><span class="line">        mp.mEventHandler.sendMessage(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之前我们在Java层的MediaPlayer.java文件的构造函数中，分析到最后有一个native_setup，在android_media_MediaPlayer.cpp中找到对应的函数，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用C++层的native setup方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mediaplayerThis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attributionSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">native_setup</span><span class="params">(Object mediaplayerThis,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Parcel attributionSource)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码位于：frameworks/base/media/jni/android_media_MediaPlayer.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_media_MediaPlayer_native_setup</span><span class="params">(JNIEnv *env, jobject thiz, jobject weak_this,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       jobject jAttributionSource)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;native_setup&quot;</span>);</span><br><span class="line">    Parcel* parcel = <span class="built_in">parcelForJavaObject</span>(env, jAttributionSource);</span><br><span class="line">    android::content::AttributionSourceState attributionSource;</span><br><span class="line">    attributionSource.<span class="built_in">readFromParcel</span>(parcel);</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = sp&lt;MediaPlayer&gt;::<span class="built_in">make</span>(attributionSource);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/RuntimeException&quot;</span>, <span class="string">&quot;Out of memory&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  给MediaPlayer创建一个listener 以便我们在Java设置的setPrepareListener、setOnCompleteListener能产生回调</span></span><br><span class="line">    <span class="comment">// create new listener and give it to MediaPlayer</span></span><br><span class="line">    sp&lt;JNIMediaPlayerListener&gt; listener = <span class="keyword">new</span> <span class="built_in">JNIMediaPlayerListener</span>(env, thiz, weak_this);</span><br><span class="line">    mp-&gt;<span class="built_in">setListener</span>(listener);</span><br><span class="line">    <span class="comment">// 对于Java层来说。C++中的MediaPlayer事不透明的，也无需关心其对应的逻辑</span></span><br><span class="line">    <span class="comment">// Stow our new C++ MediaPlayer in an opaque field in the Java object.</span></span><br><span class="line">    <span class="built_in">setMediaPlayer</span>(env, thiz, mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到会设置一些回调用的listener及创建C++中的MediaPlayer对象。</p>
<h2 id="setDataSource过程"><a href="#setDataSource过程" class="headerlink" title="setDataSource过程"></a>setDataSource过程</h2><p>上面就是MediaPlayer的构造过程。构造后接下来要设置数据源，进而到了setDataSource过程，下面看看setDataSource做了什么操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(String path, String[] keys, String[] values,</span></span><br><span class="line"><span class="params">        List&lt;HttpCookie&gt; cookies)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, IllegalArgumentException, SecurityException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(path); <span class="comment">//解析path</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">scheme</span> <span class="operator">=</span> uri.getScheme();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(scheme)) &#123;</span><br><span class="line">        path = uri.getPath();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheme != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理非文件资源</span></span><br><span class="line">        nativeSetDataSource(</span><br><span class="line">            MediaHTTPService.createHttpServiceBinderIfNecessary(path, cookies),</span><br><span class="line">            path,</span><br><span class="line">            keys,</span><br><span class="line">            values);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理文件类型的视频播放</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">        setDataSource(is.getFD());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeSetDataSource</span><span class="params">(</span></span><br><span class="line"><span class="params">    IBinder httpServiceBinder, String path, String[] keys, String[] values)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, IllegalArgumentException, SecurityException, IllegalStateException;</span><br></pre></td></tr></table></figure>

<p>调用nativeSetDataSource代码逻辑开始进入JNI层，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nativeSetDataSource&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(Landroid/os/IBinder;Ljava/lang/String;[Ljava/lang/String;&quot;</span></span><br><span class="line">    <span class="string">&quot;[Ljava/lang/String;)V&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)android_media_MediaPlayer_setDataSourceAndHeaders</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>我们看一下android_media_MediaPlayer_setDataSourceAndHeaders方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码位于：frameworks/base/media/jni/android_media_MediaPlayer.cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">android_media_MediaPlayer_setDataSourceAndHeaders</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv *env, jobject thiz, jobject httpServiceBinderObj, jstring path,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobjectArray keys, jobjectArray values)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = <span class="built_in">getMediaPlayer</span>(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalStateException&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalArgumentException&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tmp = env-&gt;<span class="built_in">GetStringUTFChars</span>(path, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;  <span class="comment">// Out of memory</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;setDataSource: path %s&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="function">String8 <span class="title">pathStr</span><span class="params">(tmp)</span></span>;</span><br><span class="line">    env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(path, tmp);</span><br><span class="line">    tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We build a KeyedVector out of the key and val arrays</span></span><br><span class="line">    KeyedVector&lt;String8, String8&gt; headersVector;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ConvertKeyValueArraysToKeyedVector</span>(</span><br><span class="line">            env, keys, values, &amp;headersVector)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;IMediaHTTPService&gt; httpService;</span><br><span class="line">    <span class="keyword">if</span> (httpServiceBinderObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过Binder机制将httpServiceBinderObj传给IPC，并且返回Binder对象</span></span><br><span class="line">        sp&lt;IBinder&gt; binder = <span class="built_in">ibinderForJavaObject</span>(env, httpServiceBinderObj);</span><br><span class="line">        <span class="comment">// 然后强转成IMediaHTTPService</span></span><br><span class="line">        httpService = <span class="built_in">interface_cast</span>&lt;IMediaHTTPService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始进行设置setDataSource的状态判断，和上面的文件操作一张</span></span><br><span class="line">    <span class="type">status_t</span> opStatus =</span><br><span class="line">        mp-&gt;<span class="built_in">setDataSource</span>(</span><br><span class="line">                httpService,</span><br><span class="line">                pathStr,</span><br><span class="line">                headersVector.<span class="built_in">size</span>() &gt; <span class="number">0</span>? &amp;headersVector : <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 从这里开始调用JNIEnv*中的getIntField函数获取对应变量</span></span><br><span class="line">    <span class="built_in">process_media_player_call</span>(</span><br><span class="line">            env, thiz, opStatus, <span class="string">&quot;java/io/IOException&quot;</span>,</span><br><span class="line">            <span class="string">&quot;setDataSource failed.&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，setDataSource过程就完成了。这里需要注意两点，一点是从Java→JNI→C++的正向调用过程（前面从Java层到Native层都是正向过程），一点是C++→JNI→Java的过程（如mp-&gt;setDataSource( httpService, pathStr,headersVector.size() &gt; 0? &amp;headersVector : NULL），这样来回调的好处是什么？好处有如下这几点。</p>
<p>安全性，封装在Native层的代码是so形式的，破坏性风险小。</p>
<p> 效率高，在运行速度上C++执行时间短，且底层也是用C++语言编写的。对于复杂的渲染及对时间要求高的渲染，放在Native层是最好不过的选择。</p>
<p>连通性，正向调用将值传入，反向调用把处理过的值通知回去。相当于一根管道。</p>
<h2 id="setDisplay过程"><a href="#setDisplay过程" class="headerlink" title="setDisplay过程"></a>setDisplay过程</h2><p>接下来看看在setDataSource之后，开始进行的mp.setDisplay(holder)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码位于：frameworks/base/media/java/android/media/MediaPlayer.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDisplay</span><span class="params">(SurfaceHolder sh)</span> &#123;</span><br><span class="line">    <span class="comment">// 给Surfacesh设置一个控制器，用于展示视频图像</span></span><br><span class="line">    mSurfaceHolder = sh;</span><br><span class="line">    <span class="comment">// 获取surface的对象实例</span></span><br><span class="line">    Surface surface;</span><br><span class="line">    <span class="keyword">if</span> (sh != <span class="literal">null</span>) &#123;</span><br><span class="line">        surface = sh.getSurface();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        surface = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给视频设置一个surface.</span></span><br><span class="line">    <span class="comment">// 这个函数是一个Native函数</span></span><br><span class="line">    _setVideoSurface(surface);</span><br><span class="line">    <span class="comment">// 更新surface到屏幕上</span></span><br><span class="line">    updateSurfaceScreenOn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面代码中的_setVideoSurface，同样在android_media_MediaPlayer.cpp中找到其对应的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码位于：frameworks/base/media/jni/android_media_MediaPlayer.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">setVideoSurface</span><span class="params">(JNIEnv *env, jobject thiz, jobject jsurface, jboolean mediaPlayerMustBeAlive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取MediaPlayer对象</span></span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = <span class="built_in">getMediaPlayer</span>(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mediaPlayerMustBeAlive) &#123;</span><br><span class="line">            <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalStateException&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">decVideoSurfaceRef</span>(env, thiz);</span><br><span class="line"></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; new_st;</span><br><span class="line">    <span class="keyword">if</span> (jsurface) &#123;</span><br><span class="line">        <span class="comment">// 获取Java层的Surface</span></span><br><span class="line">        <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(android_view_Surface_getSurface(env, jsurface))</span></span>;</span><br><span class="line">        <span class="comment">// 判断如果Surface，则获取IGraphicBufferProducer</span></span><br><span class="line">        <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            new_st = surface-&gt;<span class="built_in">getIGraphicBufferProducer</span>();</span><br><span class="line">            <span class="keyword">if</span> (new_st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalArgumentException&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The surface does not have a binding SurfaceTexture!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_st-&gt;<span class="built_in">incStrong</span>((<span class="type">void</span>*)decVideoSurfaceRef);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalArgumentException&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;The surface has been released&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;<span class="built_in">SetLongField</span>(thiz, fields.surface_texture, (jlong)new_st.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This will fail if the media player has not been initialized yet. This</span></span><br><span class="line">    <span class="comment">// can be the case if setDisplay() on MediaPlayer.java has been called</span></span><br><span class="line">    <span class="comment">// before setDataSource(). The redundant call to setVideoSurfaceTexture()</span></span><br><span class="line">    <span class="comment">// in prepare/prepareAsync covers for this case.</span></span><br><span class="line">    <span class="comment">// MediaPlayer如果还未初始化setSurface将失败，</span></span><br><span class="line">    mp-&gt;<span class="built_in">setVideoSurfaceTexture</span>(new_st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有如下几个概念需要理解。</p>
<p> SurfaceTexture：SurfaceTexture是Android 3.0（API 11）加入的一个类。这个类跟SurfaceView很像，可以从视频解码里面获取图像流（image stream）。但是，和SurfaceView不同的是，SurfaceTexture在接收图像流之后，不需要显示出来。SurfaceTexture不需要显示到屏幕上，因此我们可以用SurfaceTexture接收解码出来的图像流，然后从SurfaceTexture中取得图像帧的副本进行处理，处理完毕后再送给另一个SurfaceView用于显示。</p>
<p>Surface：处理被屏幕排序的原生的Buffer，Android中的Surface就是一个用来画图形（graphic）或图像（image）的地方。对于View及其子类，都是画在Surface上的，各Surface对象通过SurfaceFlinger合成到frameBuffer。每个Surface都是双缓冲的（实际上就是两个线程，一个渲染线程，一个UI更新线程），它有一个backBuffer和一个frontBuffer。在Surface中创建的Canvas对象，可用来管理Surface绘图操作，Canvas对应Bitmap，存储Surface中的内容。</p>
<p>SurfaceView：在Camera、MediaRecorder、MediaPlayer中SurfaceView经常被用来显示图像。SurfaceView是View的子类，实现了Parcelable接口，其中内嵌了一个专门用于绘制的Surface，SurfaceView可以控制这个Surface的格式和尺寸，以及Surface的绘制位置。可以理解Surface就是管理数据的地方，SurfaceView就是展示数据的地方。</p>
<p>SurfaceHolder：顾名思义，是一个管理SurfaceHolder的容器。SurfaceHolder是一个接口，其可被理解为一个Surface的监听器。通过回调函数addCallback(SurfaceHolder.Callback callback)监听Surface的创建，通过获取Surface中的Canvas对象，锁定之。所得到的Canvas对象在完成修改Surface中的数据后，释放同步锁，并提交改变Surface的状态及图像，展示新的图像数据。</p>
<p>最后总结一下，SurfaceView中调用getHolder函数，可以获得当前SurfaceView中的Surface对应的SurfaceHolder，SurfaceHolder开始对Surface进行管理操作。这里按MVC模式可以更好地理解M:Surface（图像数据）、V:SurfaceView（图像展示）、C:SurfaceHolder（图像数据管理）。MediaPlayer.java中的setDisplay操作就是对将要显示的视频进行预设置。以上就是setDisplay的过程，Java层中setDisplay的最后一行，就是通过JNI返回的Surface，时时做好更新准备。</p>
<h2 id="prepare调用"><a href="#prepare调用" class="headerlink" title="prepare调用"></a>prepare调用</h2><p>上节中我们分析了MediaPlayer从创建到setDataSource的过程，尽管分析了代码，但是没有从MediaPlayer生态上认识各类库之间的依赖调用关系。</p>
<p>MediaPlayer的核心的源文件所在的目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frameworks/av/media/libmedia/include/media/IMediaPlayerClient.h</span><br><span class="line">frameworks/av/media/libmedia/include/media/mediaplayer.h</span><br><span class="line">frameworks/av/media/libmedia/include/media/IMediaPlayer.h</span><br><span class="line">frameworks/av/media/libmedia/include/media/IMediaPlayerService.h</span><br></pre></td></tr></table></figure>

<p>在这些头文件中，mediaplayer.h提供了对上层的接口，而其他的几个头文件提供的是一些接口类（即包含了纯虚函数的类），这些接口类必须被实现类继承才能够使用。</p>
<p>MediaPlayer各个具体类之间的依赖关系图如图所示。</p>
<p><img src="/images/epub_31186334_25.jpeg" alt="img"></p>
<p>在运行的时候，整个MediaPlayer可以大致上分成Client和Server两个部分，它们分别在两个进程中运行，它们之间使用Binder机制实现IPC通信。从框架结构上看，IMediaPlayer Service.h、IMediaPlayerClient.h和mediaplayer.h这3个头文件中定义了MediaPlayer的接口和架构，在目录中有专门的MediaPlayerService.cpp和mediaplayer.cpp文件对应上面3个头文件，用于MediaPlayer架构的实现。</p>
<p>在给播放器设置数据源且展现了Surface后，你应当开始调用prepare或prepareAsync函数。对于文件类型，调用prepare函数将暂时阻塞，因为prepare是一个同步函数，直到MediaPlayer已经准备好数据即将播放，也就是播放器回调了onPrepared函数，进入Prepared状态。</p>
<p>prepare函数的执行过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码位于：frameworks/base/media/java/android/media/MediaPlayer.java</span></span><br><span class="line"><span class="comment"> * 同步调用prepare方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> <span class="keyword">throws</span> IOException, IllegalStateException &#123;</span><br><span class="line">    <span class="comment">// 调用Native方法</span></span><br><span class="line">    _prepare();</span><br><span class="line">    scanInternalSubtitleTracks();</span><br><span class="line">    <span class="comment">// DrmInfo, if any, has been resolved by now.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mDrmLock) &#123;</span><br><span class="line">        mDrmInfoResolved = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Native层的android_media_MediaPlayer_prepare函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码位于：frameworks/base/media/jni/android_media_MediaPlayer.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">android_media_MediaPlayer_prepare</span><span class="params">(JNIEnv *env, jobject thiz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取MediaPlayer对象</span></span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = <span class="built_in">getMediaPlayer</span>(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalStateException&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle the case where the display surface was set before the mp was</span></span><br><span class="line">    <span class="comment">// initialized. We try again to make it stick.</span></span><br><span class="line">    <span class="comment">// 通过getVideoSurfaceTexture获取一个IGraphicBufferProducer类型指针</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; st = <span class="built_in">getVideoSurfaceTexture</span>(env, thiz);</span><br><span class="line">    <span class="comment">// setVideoSurfaceTexture，主要给MediaPlayer传入IGraphicBufferProducer。</span></span><br><span class="line">    <span class="comment">// 这里IGraphicBufferProducer就是App和BufferQueue的重要桥梁，GraphicBufferProducer承担着单个应用进程中的UI显示需求，</span></span><br><span class="line">    <span class="comment">// 与BufferQueue打交道的就是它。</span></span><br><span class="line">    mp-&gt;<span class="built_in">setVideoSurfaceTexture</span>(st);</span><br><span class="line">    <span class="comment">// process_media_player_call是对MediaPlayer调用prepare函数后是否有异常的检测</span></span><br><span class="line">    <span class="built_in">process_media_player_call</span>( env, thiz, mp-&gt;<span class="built_in">prepare</span>(), <span class="string">&quot;java/io/IOException&quot;</span>, <span class="string">&quot;Prepare failed.&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的getVideoSurfaceTexture获取一个IGraphicBufferProducer类型指针，2中是setVideoSurfaceTexture，主要给MediaPlayer传入IGraphicBufferProducer。这里IGraphicBufferProducer就是App和BufferQueue的重要桥梁，GraphicBufferProducer承担着单个应用进程中的UI显示需求，与BufferQueue打交道的就是它。</p>
<p>BpGraphicBufferProducer是GraphicBufferProducer在客户端这边的代理对象，负责和SurfaceFlinger交互，GraphicBufferProducer通过gbp（IGraphicBufferProducer类对象）向BufferQueue获取Buffer，然后填充UI信息，填充完毕会通知SurfaceFlinger。</p>
<p>process_media_player_call是对MediaPlayer调用prepare函数后是否有异常的检测，如果出现参数不合法，或是I&#x2F;O异常，就会抛出异常。</p>
<p>我们知道MediaPlayer还有一个prepareAsync函数，前面的思路都是顺着MediaPlayer中的create函数来的。如果是下面这种场景，即一个网络URL被发送过来，就是网络流数据传入MediaPlayer，这时就要用到prepareAsync函数了：</p>
<h2 id="prepareAsync调用"><a href="#prepareAsync调用" class="headerlink" title="prepareAsync调用"></a>prepareAsync调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码位于：frameworks/base/media/java/android/media/MediaPlayer.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">prepareAsync</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到prepareAsync是一个Native方法，那我们什么时候回用到这个方法呢？</p>
<p>如果是下面这种场景，即一个网络URL被发送过来，就是网络流数据传入MediaPlayer，这时就要用到prepareAsync函数了</p>
<p>分析MediaPlayer中的prepareAsync函数：在setDataSource中且展现了Surface后，开始调用prepare或prepareAsync函数，对于网络视频流类型，尽量调用prepareAsync函数，因为是异步的，不会导致没有足够的数据影响起播。</p>
<p>下面分析android_media_MediaPlayer_prepareAsync函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码位于：frameworks/base/media/jni/android_media_MediaPlayer.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">android_media_MediaPlayer_prepareAsync</span><span class="params">(JNIEnv *env, jobject thiz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取MediaPlayer的对象</span></span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = <span class="built_in">getMediaPlayer</span>(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalStateException&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle the case where the display surface was set before the mp was</span></span><br><span class="line">    <span class="comment">// initialized. We try again to make it stick.</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; st = <span class="built_in">getVideoSurfaceTexture</span>(env, thiz);</span><br><span class="line">    mp-&gt;<span class="built_in">setVideoSurfaceTexture</span>(st);</span><br><span class="line">    <span class="comment">// 可以看到基本和android_media_MediaPlayer_prepare调用是一样的</span></span><br><span class="line">    <span class="built_in">process_media_player_call</span>( env, thiz, mp-&gt;<span class="built_in">prepareAsync</span>(), <span class="string">&quot;java/io/IOException&quot;</span>, <span class="string">&quot;Prepare Async failed.&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到基本和android_media_MediaPlayer_prepare调用是一样的</p>
<p>除了最后process_media_player_call中的mp-&gt;prepareAsync在判断状态时不一样，它的操作结果经过回调通知Java层。</p>
<p>下面看看frameworks&#x2F;av&#x2F;media&#x2F;libmedia&#x2F;mediaplayer.cpp中的prepareAsync函数（C++代码）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码位于：frameworks/av/media/libmedia/mediaplayer.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">MediaPlayer::prepareAsync</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;prepareAsync&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取互斥信号量句柄</span></span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="comment">// 调用prepareAsync_l</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">prepareAsync_l</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着分析prepareAsync_l函数实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码位于：代码位于：frameworks/av/media/libmedia/mediaplayer.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 必须在锁住后调用此函数</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">MediaPlayer::prepareAsync_l</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 必须获取到信号量锁之后调用此函数</span></span><br><span class="line">    <span class="keyword">if</span> ( (mPlayer != <span class="number">0</span>) &amp;&amp; ( mCurrentState &amp; (MEDIA_PLAYER_INITIALIZED | MEDIA_PLAYER_STOPPED) ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioAttributesParcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mPlayer-&gt;<span class="built_in">setParameter</span>(KEY_PARAMETER_AUDIO_ATTRIBUTES, *mAudioAttributesParcel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 设置音频流类型，在IMediaPlayer对应的transact操作是SET_AUDIO_STREAM_TYPE</span></span><br><span class="line">            mPlayer-&gt;<span class="built_in">setAudioStreamType</span>(mStreamType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前的状态设置为MEDIA_PLAYER_PREPARING</span></span><br><span class="line">        mCurrentState = MEDIA_PLAYER_PREPARING;</span><br><span class="line">        <span class="comment">// 最好调用mPlayer-&gt;prepareAsync()方法）</span></span><br><span class="line">        <span class="keyword">return</span> mPlayer-&gt;<span class="built_in">prepareAsync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;prepareAsync called in state %d, mPlayer(%p)&quot;</span>, mCurrentState, mPlayer.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面继续分析prepareAsync函数，mp-&gt;prepareAsync对应的BnMediaPlayer操作如下：</p>
<p>接着分析MediaPlayerService::Client::prepareAsync函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码位于：frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">status_t</span> MediaPlayerService::Client::<span class="built_in">prepareAsync</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%d] prepareAsync&quot;</span>, mConnId);</span><br><span class="line">    sp&lt;MediaPlayerBase&gt; p = <span class="built_in">getPlayer</span>();</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">   <span class="comment">// 这里调用了AwesomePlayer的prepareAsync函数：</span></span><br><span class="line">    <span class="type">status_t</span> ret = p-&gt;<span class="built_in">prepareAsync</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CALLBACK_ANTAGONIZER</span></span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">&quot;start Antagonizer&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == NO_ERROR) mAntagonizer-&gt;<span class="built_in">start</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着分析MediaPlayerService::Client::prepareAsync函数：</p>
<p>​	</p>
<p>这里调用了AwesomePlayer的prepareAsync函数：</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.frewen.wang">Frewen.Wang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.frewen.wang/2022/01/05/01.AuraTechNotes/04.Android/13.Android%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0/03.Android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E4%B9%8BMediaPlayer%E6%BA%90%E7%A0%81/">http://www.frewen.wang/2022/01/05/01.AuraTechNotes/04.Android/13.Android%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0/03.Android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E4%B9%8BMediaPlayer%E6%BA%90%E7%A0%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.frewen.wang" target="_blank">麦溪·在路上</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a><a class="post-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/">性能监控</a><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post_share"><div class="social-share" data-image="/img/frewen_tech.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_square.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_square.jpg" alt="微信打赏"/></a><div class="post-qr-code-desc">微信打赏</div></li><li class="reward-item"><a href="/img/alipay_square.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay_square.jpg" alt="支付宝打赏"/></a><div class="post-qr-code-desc">支付宝打赏</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/05/01.AuraTechNotes/04.Android/13.Android%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0/02.Android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/" title="Android音视频学习之视频编码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android音视频学习之视频编码</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/05/01.AuraTechNotes/04.Android/13.Android%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0/05.%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E4%B9%8BAudioRecord%E5%BD%95%E5%88%B6PCM%E9%9F%B3%E9%A2%91/" title="音视频开发之AudioRecord录制PCM音频"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">音视频开发之AudioRecord录制PCM音频</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/05/01.AuraTechNotes/04.Android/01.Android%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%B8%E5%85%B3/01.Android%E4%B8%AD%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E7%BA%B2/" title="Android中高级面试题大纲"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">Android中高级面试题大纲</div></div></a></div><div><a href="/2022/01/05/01.AuraTechNotes/04.Android/02.Android%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/01.ADB%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/" title="Android之BroadcastReceiver基础学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">Android之BroadcastReceiver基础学习</div></div></a></div><div><a href="/2022/01/05/01.AuraTechNotes/04.Android/07.Android%E4%B9%8BAnimation%E5%AD%A6%E4%B9%A0/05.AnimationDrawable%E7%9A%84%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" title="AnimationDrawable的源码学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">AnimationDrawable的源码学习</div></div></a></div><div><a href="/2022/01/05/01.AuraTechNotes/04.Android/08.Android%E4%B9%8B%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/03.leakcanary2.0%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="leakcanary2.0的学习与使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">leakcanary2.0的学习与使用</div></div></a></div><div><a href="/2022/01/05/01.AuraTechNotes/04.Android/12.Android%E4%B9%8B%E7%B3%BB%E7%BB%9FAPI%E5%AD%A6%E4%B9%A0/01.Android%E4%B9%8B%E6%9F%A5%E7%9C%8BAndroid%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7/" title="Android之查看Android系统相关的属性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">Android之查看Android系统相关的属性</div></div></a></div><div><a href="/2022/01/05/01.AuraTechNotes/04.Android/13.Android%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0/01.Android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" title="Android音视频多媒体学习路线"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">Android音视频多媒体学习路线</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/frewen_tech.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Frewen.Wang</div><div class="author-info__description">在青麦地上跑着,雪和太阳的光芒</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">858</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">146</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FrewenWang"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/FrewenWang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:frewen1225@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://plus.google.com/FrewenWong" target="_blank" title="Google"><i class="fa-brands fa-google"></i></a><a class="social-icon" href="https://twitter.com/FrewenWong" target="_blank" title="Twitter"><i class="fa-brands fa-twitter"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MediaPlayer%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">MediaPlayer的状态图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Idle%E7%8A%B6%E6%80%81%E5%8F%8AEnd%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">Idle状态及End状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Error%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">Error状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Initialized%E7%8A%B6%E6%80%81"><span class="toc-number">1.4.</span> <span class="toc-text">Initialized状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prepared%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.</span> <span class="toc-text">Prepared状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MediaPlayer%E5%88%9B%E5%BB%BA"><span class="toc-number">1.6.</span> <span class="toc-text">MediaPlayer创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setDataSource%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">setDataSource过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setDisplay%E8%BF%87%E7%A8%8B"><span class="toc-number">1.8.</span> <span class="toc-text">setDisplay过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prepare%E8%B0%83%E7%94%A8"><span class="toc-number">1.9.</span> <span class="toc-text">prepare调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prepareAsync%E8%B0%83%E7%94%A8"><span class="toc-number">1.10.</span> <span class="toc-text">prepareAsync调用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/28/01.AuraTechNotes/09.Python/12.python%E7%9A%84pycharm%E7%9A%84%E4%BD%BF%E7%94%A8/01.pycharm%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="无题">无题</a><time datetime="2023-07-28T11:06:28.000Z" title="发表于 2023-07-28 19:06:28">2023-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/27/01.AuraTechNotes/09.Python/11.python%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/01.python%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="无题">无题</a><time datetime="2023-07-27T02:02:00.000Z" title="发表于 2023-07-27 10:02:00">2023-07-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/20/01.AuraTechNotes/16.Linux/01.Linux%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/01.%E5%9F%BA%E4%BA%8EWindows11%E5%AE%89%E8%A3%85Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/" title="基于Windows11安装Ubuntu双系统">基于Windows11安装Ubuntu双系统</a><time datetime="2023-07-19T16:00:00.000Z" title="发表于 2023-07-20 00:00:00">2023-07-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/17/01.AuraTechNotes/09.Python/01.python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/12.%E6%90%AD%E5%BB%BAbaidu%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" title="无题">无题</a><time datetime="2023-07-17T12:35:38.000Z" title="发表于 2023-07-17 20:35:38">2023-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/13/01.AuraTechNotes/20.AILearning/06.%E6%B7%B1%E5%BA%A6%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E9%87%8F%E5%8C%96%E5%8A%A0%E9%80%9F/08.QNN%E6%8E%A8%E7%90%86%E9%87%8F%E5%8C%96%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" title="无题">无题</a><time datetime="2023-06-13T14:28:06.000Z" title="发表于 2023-06-13 22:28:06">2023-06-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Frewen.Wang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'http://www.frewen.wang/2022/01/05/01.AuraTechNotes/04.Android/13.Android%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0/03.Android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E4%B9%8BMediaPlayer%E6%BA%90%E7%A0%81/'
    this.page.identifier = '/2022/01/05/01.AuraTechNotes/04.Android/13.Android%E4%B9%8B%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0/03.Android%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E4%B9%8BMediaPlayer%E6%BA%90%E7%A0%81/'
    this.page.title = 'Android音视频学习之MediaPlayer源码'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !false) {
    if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>